<!DOCTYPE html><html><head><title></title></head><body><script src="../import-map.js"></script><script type="module">
import Starter, { THREE }   from '../lib/Starter.js';
import ShapePointsMesh     	from '../lib/meshes/ShapePointsMesh.js';
import DynLinesMesh        	from '../lib/meshes/DynLineMesh.js';
import { UtilGltf2, Gltf2 } from '../lib/UtilGltf2.js';
import { vec3, quat }       from 'gl-matrix';
import TrackLoader          from './lib/TrackLoader.js';

let App;
let Debug = {};
let Ref = {
    radius      : 0.3,
    onSurface   : false,
    surfacePos  : [0,0,0],
    surfaceNorm : [0,0,0],
    surfaceF    : [0,0,0],

    marble  : null,
    track   : null,
    rbody   : null,
    ray     : new THREE.Raycaster(),
};

window.addEventListener( "load", async _=>{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	App = new Starter( { webgl2:false, grid:true } );
	App.setCamera( 60, 20, 9, [0,0.8,0] );
    App.onRender = onRender;

    App.add( (Debug.pnt = new ShapePointsMesh() ) );
    App.add( (Debug.ln  = new DynLinesMesh() ) );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const loader = await new TrackLoader().init();
    const meshes = loader.loadSet([
        { name: 'slant_solid_long_C' },
        { name: 'bend_medium', pos: [1.5, 0, 2.0], rot: [0,Math.PI * 0.5,0] },
    ], App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.sim = new Simulation();
    Ref.sim.setPosition( [0,2.5,-0.5] );
    Ref.sim.tracks = meshes;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.sim.update( 0.01 );
    App.render();
});

let physicTick = -1;
let run = true;
function onRender( dt, et ){
    Ref.sim.update( dt );

    // let t = Math.floor( et / 0.01 );
    // if( t !== physicTick && run ){
    //     physicTick = t;

    //     rayCast();
    //     if( Ref.onSurface ){
    //         slopForce();
    //         Ref.rbody.addForce( Ref.surfaceF );
    //         Ref.rbody.useGravity = false;
    //     }else{
    //         Ref.rbody.useGravity = true;
    //     }
        
    //     if( run ) Ref.rbody.update( dt );

    //     if( Ref.rbody.position[1] < -1 ){
    //         Ref.rbody.setPosition( [0,2.5,-0.5] ).resetVelocity();
    //     }
    // }
    
}

function rayCast(){
    Ref.ray.ray.origin.fromArray( Ref.rbody.position );
    Ref.ray.ray.direction.fromArray( [0,-1,0] );

    const hits = Ref.ray.intersectObjects( Ref.track, true );
    if( hits.length === 0 ) return null;

    if( hits[ 0 ].distance <= Ref.radius ){
        vec3.copy( Ref.surfacePos, hits[0].point.toArray() );
        vec3.copy( Ref.surfaceNorm, hits[0].face.normal.toArray() );

        const pos = vec3.add( [0,0,0], Ref.surfacePos, [0,Ref.radius,0] )
        Ref.rbody.setPosition( pos );

        if( !Ref.onSurface ) Ref.rbody.scaleVelocity( 0.5 );

        Ref.onSurface = true;
    }else{
        Ref.onSurface = false;
    }
}

function slopForce(){
    const invRay  = [0,1,0];
    const rotAxis = vec3.cross( [0,0,0], invRay, Ref.surfaceNorm );  // Find rotation axis for angular rotation
    const fwd     = vec3.cross( [0,0,0], rotAxis, Ref.surfaceNorm );   // Find Direction of slop force
    vec3.normalize( rotAxis, rotAxis );
    vec3.normalize( fwd, fwd );

    const dot     = vec3.dot( invRay, fwd );
    if( dot !== 0 ){
        vec3.scale( Ref.surfaceF, fwd, dot * -9.81 );
    }
    
    // Debug.ln.add( Ref.surfacePos, vec3.scaleAndAdd([0,0,0], Ref.surfacePos, rotAxis, 2 ), 0xff0000, null, true );
    // Debug.ln.add( Ref.surfacePos, vec3.scaleAndAdd([0,0,0], Ref.surfacePos, fwd, 2 ), 0x00ffff, null, false );
}

function rayTest( mesh ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const pos = [0,2.5,-0.5];
    const dir = [0,-1,0];

    Debug.pnt.add( pos, 0x00ffff, 3 );
    Debug.ln.add( pos, vec3.scaleAndAdd([0,0,0], pos, dir, 2 ), 0x00ffff, null, true );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const vPos      = new THREE.Vector3().fromArray( pos );
    const vDir      = new THREE.Vector3().fromArray( dir );
    const ray       = new THREE.Raycaster( vPos, vDir );
    const hit       = ray.intersectObject( mesh )[ 0 ];

    const hitPos    = hit.point.toArray();
    const hitNorm   = hit.face.normal.toArray();

    Debug.pnt.add( hitPos, 0x00aaaa, 7, 6 );
    Debug.ln.add( hitPos, vec3.scaleAndAdd([0,0,0], hitPos, hitNorm, 2 ), 0xff0000 );

    // Get the opposite direction of the ray;
    const invDir  = vec3.negate( [0,0,0], dir ); 
    
    // Find rotation axis for angular rotation
    const rotAxis = vec3.cross( [0,0,0], invDir, hitNorm );

    // Find Direction of slop force
    const fwd     = vec3.cross( [0,0,0], rotAxis, hitNorm );

    // Maybe use Dot to determine speed somehow? At least
    // if its negative the direction is going in a downward direction
    const strength = vec3.dot( invDir, fwd );

    vec3.normalize( rotAxis, rotAxis );
    vec3.normalize( fwd, fwd );

    Debug.ln.add( hitPos, vec3.scaleAndAdd([0,0,0], hitPos, rotAxis, 2 ), 0xff0000, null, true );
    Debug.ln.add( hitPos, vec3.scaleAndAdd([0,0,0], hitPos, fwd, 2 ), 0x00ffff, null, false );
}

// https://github.com/dimforge/rapier/blob/master/src/dynamics/rigid_body.rs
// https://github.com/dimforge/rapier/blob/master/src/dynamics/rigid_body_components.rs#L174

// Note: Impulse is a one time Force applied but as force = impulse * mass
class RigidBody{
    // #region MAIN
    mesh            = null;
    useGravity      = true;

    mass            = 1;
    friction        = 0.4;
    
    position        = [0,0,0];
    rotation        = [0,0,0,1];
    linVelocity     = [0,0,0];
    angVelocity     = [0,0,0];
    
    gravityConst    = 9.81;
    gravityNorm     = [0,-1,0];
    gravity         = vec3.scale( [0,0,0], this.gravityNorm, this.gravityConst );

    force           = [0,0,0];          // Linear Force
    torque          = [0,0,0];          // Angular Force

    // Hollow Sphere Inertia = 2/3 * ( mr^2 )
    // Solid Sphere Inertia  = 2/5 * ( mr^2 )
    radius          = 1.0;
    inertia         = 2/5 * ( this.mass * ( this.radius**2 ) );

    constructor(){}
    // #endregion

    // #region SETTERS
    setMesh( m ){ this.mesh = m; return this; }

    resetVelocity(){
        vec3.set( this.linVelocity, 0, 0, 0 );
        vec3.set( this.angVelocity, 0, 0, 0 );
        return this;
    }

    scaleVelocity( scl ){
        vec3.scale( this.linVelocity, this.linVelocity, scl );
        vec3.scale( this.angVelocity, this.angVelocity, scl );
        return this;
    }
    
    setPosition( p ){ 
        vec3.copy( this.position, p );
        if( this.mesh ) this.mesh.position.fromArray( p );
        return this;
    }
    
    setRadius( r ){
        this.radius     = r;
        this.inertia    = 2/5 * ( this.mass * ( this.radius**2 ) );
        return this;
    }

    addForce( force, atPos=null ){
        vec3.add( this.force, this.force, force );
        if( atPos ){
            // 2D Torque = radius.x * force.y - radius.y * force.x ( Radius = PointOfForce - CenterOfMass )
            // 3D Torque = cross( radius, force );
            const torque = vec3.cross( [0,0,0], atPos, force );
            vec3.add( this.torque, this.torque, torque );
        }
        return this;
    }

    addSurfaceForce( surfNorm ){
        const d = vec3.dot( surfNorm, this.gravityNorm );
        const f = vec3.scale( [0,0,0], surfNorm, d * -this.gravityConst );
        vec3.add( this.force, this.force, f );
        return this;
    }
    // #endregion

    update( dt ){
        const accel = [0,0,0];
        const f     = [0,0,0];
        const tmp   = [0,0,0];

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Accumulate Forces
        vec3.add( f, f, this.force );
        if( this.useGravity ) vec3.add( f, f, this.gravity );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Handle Linear Velocity

        // Acceleration  = force / mass
        vec3.scale( accel, f, 1 / this.mass );                                  
        
        // Velocity += Acceleration * Time
        vec3.scaleAndAdd( this.linVelocity, this.linVelocity, accel, dt );      

        // Velocity += Invert( Vel ) * Factor * Time
        vec3.scaleAndAdd( this.linVelocity, this.linVelocity, this.linVelocity, -this.friction * dt ); 

        // Position += Velocity * Time
        vec3.scaleAndAdd( this.position, this.position, this.linVelocity, dt ); 

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Handle Anglular Velocity
        const angAccel = vec3.scale( [0,0,0], this.torque, 1 / this.inertia );

        // Velocity += Acceleration + dt;
        vec3.scaleAndAdd( this.angVelocity, this.angVelocity, angAccel, dt );

        // Velocity += Invert( Vel ) * Factor * Time
        vec3.scaleAndAdd( this.angVelocity, this.angVelocity, this.angVelocity, -this.friction * dt ); 

        // Angular Change = Velocity * Time
        const axis    = vec3.scale( [0,0,0], this.angVelocity, dt );
        const angDist = vec3.length( axis ); // Length is the angle of rotation
        vec3.normalize( axis, axis );        // Normalize to get axis of rotation for
    
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Apply Position
        this.mesh.position.fromArray( this.position );

        // Apply Rotation
        const q = quat.setAxisAngle( [0,0,0,1], axis, angDist );
        quat.mul( this.rotation, q, this.rotation );
        this.mesh.quaternion.fromArray( this.rotation );

        // Reset
        vec3.set( this.force, 0, 0, 0 );
        vec3.set( this.torque, 0, 0, 0 );
    }
}


class Simulation{
    // #region MAIN
    tracks      = null;
    marble      = null;
    radius      = 0.3;

    caster      = new THREE.Raycaster();
    ray         = this.caster.ray;

    time        = 0;
    tickLimit   = 0.05;

    surface     = {
        range       : this.radius + 0.001,
        pos         : [0,0,0],
        norm        : [0,0,0],
        touching    : false,
        collision   : false,
    };

    constructor(){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Create sphere with rigidbody
        const geo    = new THREE.SphereGeometry( this.radius, 16, 8 );
        const sphere = new THREE.Mesh( geo, new THREE.MeshPhongMaterial( { color: 0xffff00 } ) );
        App.add( sphere );
    
        this.marble = new RigidBody()
            .setMesh( sphere )
            .setRadius( this.radius );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        this.caster.far = this.radius * 3;
    }
    // #endregion

    // #region METHODS
    setPosition( pos ){ this.marble.setPosition( pos ); return this; }
    // #endregion

    runRaycasts(){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Setup Ray
        const pos = this.marble.position.slice();
        const dir = [ 0, -1, 0 ];
        //pos[1] += this.radius * 1.1;

        //console.log( pos );

        this.ray.origin.fromArray( pos );
        this.ray.direction.fromArray( dir );

        Debug.ln.add( pos, vec3.scaleAndAdd( dir, pos, dir, this.caster.far ), 0x00ffff );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Run raycast to find surface below marble
        const hits = this.caster.intersectObjects( this.tracks, true );
        if( hits.length ){
            const h       = hits[ 0 ];
            let   inRange = ( h.distance <= this.surface.range );

            // Set surface information
            vec3.set( this.surface.pos, h.point.x, h.point.y, h.point.z );
            vec3.set( this.surface.norm, h.face.normal.x, h.face.normal.y, h.face.normal.z );
           
            this.surface.collision = ( !this.surface.touching && inRange ); // Did marble just hit the surface in this frame?
            this.surface.touching  = inRange;                               // Set if the marbile is touching a surface

            // Debug surface position & normal
            Debug.ln.add( this.surface.pos, vec3.scaleAndAdd( [0,0,0], this.surface.pos, this.surface.norm, 5 ), 0xff0000 );
            Debug.pnt.add( this.surface.pos, 0xff0000, 5, 6 );  
        }else{
            this.surface.touching = false;
        }
    }

    update( dt ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        this.time += dt;
        if( this.time < this.tickLimit ) return;
        this.time = 0;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Debug.ln.reset();
        Debug.pnt.reset();

        this.marble.update( dt );
        this.runRaycasts();

        if( this.surface.collision ){
            this.marble.scaleVelocity( 0.5 );
            console.log( 'collision' );
        }

        if( this.surface.touching ){
            const v = vec3.sub( [0,0,0], this.marble.position, this.surface.pos );
            vec3.normalize( v, v );
            vec3.scale( v, v, this.radius );
            vec3.add( v, this.surface.pos, v );

            this.marble.setPosition( v );
            this.marble.addSurfaceForce( this.surface.norm );
        }

        Debug.ln.add( this.marble.position, vec3.add([0,0,0], this.marble.position, this.marble.linVelocity ), 0xffff00 );

        Debug.ln._updateGeometry();
        Debug.pnt._updateGeometry();

        // RayCast to determine if touching the surface
        // Test
    }
}

</script></body></html>